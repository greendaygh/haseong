<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Haseong">
<meta name="dcterms.date" content="2023-08-17">

<title>Haseong - Automation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Haseong</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lectures.html" rel="" target="">
 <span class="menu-text">Lectures</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../media.html" rel="" target="">
 <span class="menu-text">Media</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#automation" id="toc-automation" class="nav-link active" data-scroll-target="#automation">Automation</a>
  <ul class="collapse">
  <li><a href="#논문" id="toc-논문" class="nav-link" data-scroll-target="#논문">논문</a>
  <ul class="collapse">
  <li><a href="#enabling-high-throughput-biology-with-flexible-open-source-automation" id="toc-enabling-high-throughput-biology-with-flexible-open-source-automation" class="nav-link" data-scroll-target="#enabling-high-throughput-biology-with-flexible-open-source-automation">Enabling high-throughput biology with flexible open-source automation</a></li>
  <li><a href="#automated-rational-strain-construction-based-on-high-throughput-conjugation" id="toc-automated-rational-strain-construction-based-on-high-throughput-conjugation" class="nav-link" data-scroll-target="#automated-rational-strain-construction-based-on-high-throughput-conjugation">Automated Rational Strain Construction Based on High-Throughput Conjugation</a></li>
  <li><a href="#자동화-코드-참고할만한-저널" id="toc-자동화-코드-참고할만한-저널" class="nav-link" data-scroll-target="#자동화-코드-참고할만한-저널">자동화 코드 참고할만한 저널</a></li>
  </ul></li>
  <li><a href="#dna-bot-a-low-cost-automated-dna-assembly-platform-for-synthetic-biology" id="toc-dna-bot-a-low-cost-automated-dna-assembly-platform-for-synthetic-biology" class="nav-link" data-scroll-target="#dna-bot-a-low-cost-automated-dna-assembly-platform-for-synthetic-biology"><strong>DNA-BOT: a low-cost, automated DNA assembly platform for synthetic biology</strong></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Automation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">syntheic biology</div>
    <div class="quarto-category">automation</div>
    <div class="quarto-category">biofoundry</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Haseong </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 17, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="automation" class="level1">
<h1>Automation</h1>
<section id="논문" class="level2">
<h2 class="anchored" data-anchor-id="논문">논문</h2>
<section id="enabling-high-throughput-biology-with-flexible-open-source-automation" class="level3">
<h3 class="anchored" data-anchor-id="enabling-high-throughput-biology-with-flexible-open-source-automation">Enabling high-throughput biology with flexible open-source automation</h3>
<pre><code>https://www.embopress.org/doi/full/10.15252/msb.20209942
  
  복잡한 생활 시스템에 대한 우리의 이해는 높은 처리량으로 실험을 수행할 수 있는 우리의 능력에 의해 제한됩니다. 로봇 시스템은 많은 전통적인 수동 피펫팅 프로토콜을 자동화했지만 소프트웨어 제한으로 인해 수백 개의 실험을 동시에 조작, 유지 및 모니터링하는 데 필요한 고급 조작이 불가능했습니다. 여기에서는 메타 모집단 역학 시뮬레이션과 같은 사용자 지정 고처리량 실험에 필요한 복잡한 피펫팅 패턴을 실행할 수 있는 오픈 소스 Python 플랫폼인 Pyhamilton을 소개합니다. 통합 플레이트 리더를 사용하여 로봇 방법을 실시간으로 조정하기 위해 정기적인 밀도 측정을 수행함으로써 사용자 개입 없이 며칠 동안 거의 500개에 가까운 원격 모니터링 세균 배양을 대수 성장 상태로 유지합니다. 이러한 기능을 사용하여 우리는 탄소, 질소 및 인 피트니스 환경을 종합적으로 샘플링하기 위해 3중으로 100가지 연속 배양 조건의 형광 단백질 발현 및 성장률을 모니터링하여 생물 반응기 단백질 생산을 체계적으로 최적화합니다. 우리의 결과는 유연한 소프트웨어가 기존 하드웨어에 힘을 실어 새로운 유형과 규모의 실험을 가능하게 하고 생물 제조에서 기초 생물학에 이르는 영역에 힘을 실어줄 수 있음을 보여줍니다.</code></pre>
</section>
<section id="automated-rational-strain-construction-based-on-high-throughput-conjugation" class="level3">
<h3 class="anchored" data-anchor-id="automated-rational-strain-construction-based-on-high-throughput-conjugation">Automated Rational Strain Construction Based on High-Throughput Conjugation</h3>
<pre><code>    https://pubs.acs.org/doi/full/10.1021/acssynbio.0c00599
    
    분자 복제는 DNA 조립과 표적 숙주에서의 발현으로 구성되기 때문에 합성 생물학의 핵심입니다. 그러나 현재 복제는 자동화의 이점이 큰 수동적이고 시간 소모적이며 반복적인 프로세스인 경우가 가장 많습니다. 완전한 합리적인 클로닝 절차의 자동화, 즉 DNA 생성에서 표적 숙주에서의 발현까지의 자동화에는 다양한 작업과 기계의 통합이 포함됩니다. 이러한 워크플로우의 예는 드물고, 특히 설계가 합리적이고( 즉 , DNA 서열 설계가 고정되어 있으며 무작위 라이브러리를 기반으로 하지 않음) 표적 숙주가 유전적으로 다루기 쉽지 않은 경우( 예:, 열충격 변형에 민감하지 않음). 이 연구에서는 플라스미드의 합리적인 구성과 생명공학 플랫폼 유기체인 코리네박테리움 글루타미쿰 으로의 후속 컨쥬게이티브 전송을 위한 자동화된 워크플로가 제시됩니다. 전체 작업 흐름에는 맞춤형 소프트웨어 도구가 수반됩니다. 응용 예로서 조절자 Lrp를 기반으로 합리적으로 설계된 전사 인자-바이오 센서 라이브러리를 구축하고 특성화했습니다. 동적 범위가 개선된 센서를 얻었고 스크리닝에서 얻은 통찰력은 C. 글루타미쿰 Lrp의 이중 조절기 기능에 대한 증거를 제공했습니다.</code></pre>
</section>
<section id="자동화-코드-참고할만한-저널" class="level3">
<h3 class="anchored" data-anchor-id="자동화-코드-참고할만한-저널">자동화 코드 참고할만한 저널</h3>
<ul>
<li>https://journal.code4lib.org/</li>
</ul>
</section>
</section>
<section id="dna-bot-a-low-cost-automated-dna-assembly-platform-for-synthetic-biology" class="level2">
<h2 class="anchored" data-anchor-id="dna-bot-a-low-cost-automated-dna-assembly-platform-for-synthetic-biology"><strong>DNA-BOT: a low-cost, automated DNA assembly platform for synthetic biology</strong></h2>
<pre><code>다중 부분 DNA 조립은 합성 및 분자 생물학의 많은 프로젝트에서 물리적 출발점입니다. 광범위한 DNA 구조 라이브러리를 구축하여 유전자 설계 공간을 탐색하는 능력은 프로그래밍된 생물학적 시스템을 만드는 데 필수적입니다. 합성 생물학 커뮤니티에서 채택된 여러 DNA 조립 방법 및 표준으로 인해 DNA 조립 프로세스의 자동화가 이제 큰 관심을 받고 있습니다. 자동화를 통해 접근 가능한 디자인 공간을 늘리는 동시에 연구자의 시간을 덜 사용하여 더 큰 빌드를 만들 수 있습니다. 그러나 이러한 이점은 현재 장비와 소모품 모두에 높은 비용을 초래합니다. 여기에서는 DNA-BOT(OpenTrons)의 BASIC을 사용하여 저비용 DNA 어셈블리를 도입하여 이러한 제한 사항을 해결합니다. 이 목적을 위해, 우리는 오픈 소스 소프트웨어 패키지를 개발하고 10개의 유전 부분으로 구성된 88개의 구성을 동시에 조립하고 3개 유전자 오페론에 대한 프로모터, 리보솜 결합 부위 및 유전자 순서 설계 공간을 평가하여 DNA-BOT의 성능을 시연했습니다. 88개의 모든 구성은 구성당 $1.50–$5.50의 소모품 비용으로 높은 정확도로 조립되었습니다. 이것은 DNA-BOT의 효율성, 정확성 및 경제성을 보여주며 대부분의 실험실에서 접근 가능하고 자동화된 DNA 조립을 민주화합니다.</code></pre>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>